{"@context":"http://schema.org","@type":"CreativeWork","name":"The Event System","text":"\u003ch1\u003eThe Event System\u003c/h1\u003e\n\n\u003cp\u003eAPI Platform Core implements the \u003ca href=\"https://github.com/pmjones/adr\"\u003eAction-Domain-Responder\u003c/a\u003e pattern. This implementation\nis covered in depth in the \u003ca href=\"operations.jsonld#creating-custom-operations-and-controllers\"\u003eCreating custom operations and controllers\u003c/a\u003e\nchapter.\u003c/p\u003e\n\n\u003cp\u003eBasically, API Platform Core execute an action class that will return an entity or a collection of entities. Then a series\nof event listeners are executed which validate the data, persist it in database, serialize it (typically in a JSON-LD document)\nand create an HTTP response that will be sent to the client.\u003c/p\u003e\n\n\u003cp\u003eTo do so, API Platform Core leverages \u003ca href=\"https://symfony.com/doc/current/reference/events.html#kernel-events\"\u003eevents triggered by the Symfony HTTP Kernel\u003c/a\u003e.\nYou can also hook your own code to those events. They are very handy and powerful extension points available at all points\nof the request lifecycle.\u003c/p\u003e\n\n\u003cp\u003eBuilt-in event listeners are:\u003c/p\u003e\n\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003eName\u003c/th\u003e\n\u003cth\u003eEvent\u003c/th\u003e\n\u003cth\u003ePriority\u003c/th\u003e\n\u003cth\u003eDescription\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eAddFormatListener\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ekernel.request\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e7\u003c/td\u003e\n\u003ctd\u003eguess the best response format (\u003ca href=\"content-negotiation.jsonld\"\u003econtent negotiation\u003c/a\u003e)\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eReadListener\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ekernel.request\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e4\u003c/td\u003e\n\u003ctd\u003eretrieve data from the persistence system using the \u003ca href=\"data-providers.jsonld\"\u003edata providers\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eDeserializeListener\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ekernel.request\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e2\u003c/td\u003e\n\u003ctd\u003edeserialize data into a PHP entity (\u003ccode\u003eGET\u003c/code\u003e, \u003ccode\u003ePOST\u003c/code\u003e, \u003ccode\u003eDELETE\u003c/code\u003e); update the entity retrieved using the data provider (\u003ccode\u003ePUT\u003c/code\u003e)\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eValidateListener\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ekernel.view\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e64\u003c/td\u003e\n\u003ctd\u003e\u003ca href=\"validation.jsonld\"\u003evalidate data\u003c/a\u003e (\u003ccode\u003ePOST\u003c/code\u003e, \u003ccode\u003ePUT\u003c/code\u003e)\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eWriteListener\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ekernel.view\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e32\u003c/td\u003e\n\u003ctd\u003eif using the Doctrine ORM, persist data (\u003ccode\u003ePOST\u003c/code\u003e, \u003ccode\u003ePUT\u003c/code\u003e, \u003ccode\u003eDELETE\u003c/code\u003e)\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eSerializeListener\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ekernel.view\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e16\u003c/td\u003e\n\u003ctd\u003eserialize the PHP entity in string \u003ca href=\"content-negotiation.jsonld\"\u003eaccording to the request format\u003c/a\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eRespondListener\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ekernel.view\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e8\u003c/td\u003e\n\u003ctd\u003etransform serialized to a \u003ccode\u003eSymfony\\Component\\HttpFoundation\\Response\u003c/code\u003e instance\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eAddLinkHeaderListener\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ekernel.response\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003eadd a \u003ccode\u003eLink\u003c/code\u003e HTTP header pointing to the Hydra documentation\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eValidationExceptionListener\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ekernel.exception\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e0\u003c/td\u003e\n\u003ctd\u003eserialize validation exceptions in the Hydra format\u003c/td\u003e\n\u003c/tr\u003e\n\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003eExceptionListener\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e\u003ccode\u003ekernel.exception\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e-96\u003c/td\u003e\n\u003ctd\u003eserialize PHP exceptions in the Hydra format (including the stack trace in debug mode)\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\n\u003cp\u003eThose built-in listeners are always executed for routes managed by API Platform. Registering your own event listeners to\nadd extra logic is convenient.\u003c/p\u003e\n\n\u003cp\u003eIn the following example, we will send a mail each time a new book is created using the API:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-php\"\u003e\u0026lt;?php\n\n// src/AppBundle/EventSubscriber/BookMailSubscriber.php\n\nnamespace AppBundle\\EventSubscriber;\n\nuse AppBundle\\Entity\\Book;\nuse Symfony\\Component\\EventDispatcher\\EventSubscriberInterface;\nuse Symfony\\Component\\HttpFoundation\\Request;\nuse Symfony\\Component\\HttpKernel\\Event\\GetResponseForControllerResultEvent;\nuse Symfony\\Component\\HttpKernel\\KernelEvents;\n\nfinal class BookMailSubscriber implements EventSubscriberInterface\n{\n    private $mailer;\n\n    public function __construct(\\Swift_Mailer $mailer)\n    {\n        $this-\u0026gt;mailer = $mailer;\n    }\n\n    public static function getSubscribedEvents()\n    {\n        return [\n            KernelEvents::VIEW =\u0026gt; [[\u0026#39;sendMail\u0026#39;, 0]],\n        ];\n    }\n\n    public function sendMail(GetResponseForControllerResultEvent $event)\n    {\n        $book = $event-\u0026gt;getControllerResult();\n        $method = $event-\u0026gt;getRequest()-\u0026gt;getMethod();\n\n        if (!$book instanceof Book || Request::METHOD_POST !== $method) {\n            return;\n        }\n\n        $message = \\Swift_Message::newInstance()\n            -\u0026gt;setSubject(\u0026#39;A new book has been added\u0026#39;)\n            -\u0026gt;setFrom(\u0026#39;system@example.com\u0026#39;)\n            -\u0026gt;setTo(\u0026#39;contact@les-tilleuls.coop\u0026#39;)\n            -\u0026gt;setBody(sprintf(\u0026#39;The book #%d has been added.\u0026#39;, $book-\u0026gt;getId()));\n\n        $this-\u0026gt;mailer-\u0026gt;send($message);\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eIf you use the official API Platform distribution, creating the previous class is enough. \u003ca href=\"https://github.com/dunglas/DunglasActionBundle\"\u003eDunglasActionBundle\u003c/a\u003e\n(installed by default) will automatically register this subscriber as a service and will inject its dependencies using \u003ca href=\"http://symfony.com/doc/current/components/dependency_injection/autowiring.html\"\u003ethe\nautowiring feature of the Symfony Dependency Injection Container\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003eIf you don’t have DunglasActionBundle installed, \u003ca href=\"http://symfony.com/doc/current/components/http_kernel/introduction.html#creating-an-event-listener\"\u003ethe subscriber must be registered manually\u003c/a\u003e.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://doctrine-orm.readthedocs.org/en/latest/reference/events.html#reference-events-lifecycle-events\"\u003eDoctrine events\u003c/a\u003e\nare also available (if you use it) if you want to hook at the object lifecycle events.\u003c/p\u003e\n\n\u003cp\u003ePrevious chapter: \u003ca href=\"pagination.jsonld\"\u003ePagination\u003c/a\u003e\nNext chapter: \u003ca href=\"content-negotiation.jsonld\"\u003eContent Negotiation\u003c/a\u003e\u003c/p\u003e\n","author":[{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Gildas NOEL","email":"g.noel@ackwa.fr"},{"@type":"Person","Name":"Kevin Saliou","email":"kevin@saliou.name"},{"@type":"Person","Name":"Kevin Saliou","email":"kevin@saliou.name"},{"@type":"Person","Name":"Kévin Dunglas","email":"dunglas@gmail.com"},{"@type":"Person","Name":"Kevin Saliou","email":"kevin@saliou.name"}],"dateCreated":"2016-06-21T08:37:42+02:00","dateModified":"2016-09-30T11:19:24+02:00"}